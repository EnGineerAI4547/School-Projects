# -*- coding: utf-8 -*-
"""P5v1_CAP6619.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UiZwiJEX6C57xERCdqPV_abqJrTLOZkB

# CAP 6619 - Deep Learning
## Project 5
## Professor Oge Marques
## Sequential data (timeseries + text)
## Prepared by: Eric Gonzalez, Z23411215

Inspired by:

https://www.tensorflow.org/api_docs/python/tf/keras
https://github.com/sanjay-raghu/sentiment-analysis-using-LSTM-keras/blob/master/lstm-sentiment-analysis-data-imbalance-keras.ipynb
https://towardsdatascience.com/sentiment-analysis-using-lstm-step-by-step-50d074f09948
https://www.kaggle.com/ngyptr/lstm-sentiment-analysis-keras
https://www.youtube.com/watch?v=qpb_39IjZA0
https://towardsdatascience.com/illustrated-guide-to-lstms-and-gru-s-a-step-by-step-explanation-44e9eb85bf21
https://medium.com/@hunterheidenreich/understanding-keras-dense-layers-2abadff9b990

## Purpose:
The purpose of the following journal is demonstrate my first experience with time-series and sequential deep learning models. The journal will highlight two types of problems: temperature prediction and text prediction that utilize time-series and sequentially ordered data sets. Within the journal you will find the results of experiments guided by the faithful tutelage of Professor Marques and Francis Chollet by whom the exercises were crafted and codified.

## Part 1: Temperature forecasting using RNNs

Following closely along Chapter 10 of [our textbook](https://learning.oreilly.com/library/view/deep-learning-with/9781617296864),  Part 1 uses a temperature-forecasting task as a example of using DL to process and make predictions on sequential data.

Dataset: recorded at [the weather station at the Max Planck Institute for Biogeochemistry in Jena, Germany](https://www.bgc-jena.mpg.de/wetter/), it consists of 14 different quantities (such as temperature, pressure, humidity, wind direction, and so on)  recorded every 10 minutes over several years. The original data goes back to 2003, but the subset of the data we’ll download is limited to 2009–2016.

Useful sources and references for Part 1:

https://colab.research.google.com/github/fchollet/deep-learning-with-python-notebooks/blob/master/chapter10_dl-for-timeseries.ipynb

### Acquiring and inspecting the data
"""

!wget https://s3.amazonaws.com/keras-datasets/jena_climate_2009_2016.csv.zip
!unzip jena_climate_2009_2016.csv.zip

"""**Inspecting the data**"""

import os
fname = os.path.join("jena_climate_2009_2016.csv")

with open(fname) as f:
    data = f.read()

lines = data.split("\n")
header = lines[0].split(",")
lines = lines[1:]
print(header)
print(len(lines))

"""**Parsing the data**"""

import numpy as np
temperature = np.zeros((len(lines),))
raw_data = np.zeros((len(lines), len(header) - 1))
for i, line in enumerate(lines):
    values = [float(x) for x in line.split(",")[1:]]
    temperature[i] = values[1]
    raw_data[i, :] = values[:]

"""**Plotting the temperature timeseries**"""

from matplotlib import pyplot as plt
plt.plot(range(len(temperature)), temperature)

"""**Plotting the first 10 days of the temperature timeseries**"""

plt.plot(range(1440), temperature[:1440])

"""**Computing the number of samples we'll use for each data split**"""

num_train_samples = int(0.5 * len(raw_data))
num_val_samples = int(0.25 * len(raw_data))
num_test_samples = len(raw_data) - num_train_samples - num_val_samples
print("num_train_samples:", num_train_samples)
print("num_val_samples:", num_val_samples)
print("num_test_samples:", num_test_samples)

"""### Preparing the data

**Normalizing the data**
"""

mean = raw_data[:num_train_samples].mean(axis=0)
raw_data -= mean
std = raw_data[:num_train_samples].std(axis=0)
raw_data /= std

import numpy as np
from tensorflow import keras
int_sequence = np.arange(10)
dummy_dataset = keras.utils.timeseries_dataset_from_array(
    data=int_sequence[:-3],
    targets=int_sequence[3:],
    sequence_length=3,
    batch_size=2,
)

for inputs, targets in dummy_dataset:
    for i in range(inputs.shape[0]):
        print([int(x) for x in inputs[i]], int(targets[i]))

"""**Instantiating datasets for training, validation, and testing**"""

sampling_rate = 6
sequence_length = 120
delay = sampling_rate * (sequence_length + 24 - 1)
batch_size = 256

train_dataset = keras.utils.timeseries_dataset_from_array(
    raw_data[:-delay],
    targets=temperature[delay:],
    sampling_rate=sampling_rate,
    sequence_length=sequence_length,
    shuffle=True,
    batch_size=batch_size,
    start_index=0,
    end_index=num_train_samples)

val_dataset = keras.utils.timeseries_dataset_from_array(
    raw_data[:-delay],
    targets=temperature[delay:],
    sampling_rate=sampling_rate,
    sequence_length=sequence_length,
    shuffle=True,
    batch_size=batch_size,
    start_index=num_train_samples,
    end_index=num_train_samples + num_val_samples)

test_dataset = keras.utils.timeseries_dataset_from_array(
    raw_data[:-delay],
    targets=temperature[delay:],
    sampling_rate=sampling_rate,
    sequence_length=sequence_length,
    shuffle=True,
    batch_size=batch_size,
    start_index=num_train_samples + num_val_samples)

"""**Inspecting the output of one of our datasets**"""

for samples, targets in train_dataset:
    print("samples shape:", samples.shape)
    print("targets shape:", targets.shape)
    break

"""### Building a baseline "model"

In this case we will try to predict the temperature by simply assuming that the temperature 24 hours from now will be equal to the temperature right now. 

We shall use the mean absolute error (MAE) as a metric of performance and consider this (rather silly) "model" as our baseline.

**Computing the common-sense baseline MAE**
"""

def evaluate_naive_method(dataset):
    total_abs_err = 0.
    samples_seen = 0
    for samples, targets in dataset:
        preds = samples[:, -1, 1] * std[1] + mean[1]
        total_abs_err += np.sum(np.abs(preds - targets))
        samples_seen += samples.shape[0]
    return total_abs_err / samples_seen

print(f"Validation MAE: {evaluate_naive_method(val_dataset):.2f}")
print(f"Test MAE: {evaluate_naive_method(test_dataset):.2f}")

celsius_mae = 0.29 * std[1]
print(f"{celsius_mae:.2f} degrees C")

"""### Building our *real* first model

This is essentially the "simple LSTM-based model" from Listing 10.12 in the textbook.
"""

from tensorflow import keras
from tensorflow.keras import layers

inputs = keras.Input(shape=(sequence_length, raw_data.shape[-1]))
x = layers.LSTM(16)(inputs)
outputs = layers.Dense(1)(x)
model = keras.Model(inputs, outputs)

callbacks = [
    keras.callbacks.ModelCheckpoint("jena_lstm.keras",
                                    save_best_only=True)
]
model.compile(optimizer="rmsprop", loss="mse", metrics=["mae"])
history = model.fit(train_dataset,
                    epochs=10,
                    validation_data=val_dataset,
                    callbacks=callbacks)

model = keras.models.load_model("jena_lstm.keras")
print(f"Test MAE: {model.evaluate(test_dataset)[1]:.2f}")

import matplotlib.pyplot as plt
loss = history.history["mae"]
val_loss = history.history["val_mae"]
epochs = range(1, len(loss) + 1)
plt.figure()
plt.plot(epochs, loss, "bo", label="Training MAE")
plt.plot(epochs, val_loss, "b", label="Validation MAE")
plt.title("Training and validation MAE")
plt.legend()
plt.show()

"""### TODO 1: Improve the solution for temperature forecast
Write code to produce another solution to the temperature forecasting problem that outperforms the one above, i.e., has a lower Test MAE.

You can use a (combination of) different architecture (e.g., bidirectional RNN, see Listing 10.24 in the textbook), dropout and/or other regularization strategies, hyperparameter optimizations, or any other acceptable "trick" in the deep learning world.
"""

from keras.models import Sequential
from keras import layers

model = Sequential()
model.add(layers.GRU(32,
                     dropout=0.2,
                     recurrent_dropout=0.2,
                     input_shape=(sequence_length, raw_data.shape[-1])))

model.add(layers.Dense(1))



model.compile(optimizer="rmsprop", loss="mse", metrics=["mae"])
history = model.fit(train_dataset,
                              epochs=10,
                              validation_data=val_dataset)


print(f"Test MAE: {model.evaluate(test_dataset)[1]:.2f}")

print(f"Test MAE: {model.evaluate(test_dataset)[1]:.2f}")

import matplotlib.pyplot as plt
loss = history.history["mae"]
val_loss = history.history["val_mae"]
epochs = range(1, len(loss) + 1)
plt.figure()
plt.plot(epochs, loss, "bo", label="Training MAE")
plt.plot(epochs, val_loss, "b", label="Validation MAE")
plt.title("Training and validation MAE")
plt.legend()
plt.show()

"""### Summary table
(Example, manually generated)

You can use the table below to show a summary of the experimental results. **Replace the Test MAE values and other contents with your own!**

| Method | Test MAE | Remarks |
| --- | --- | --- |
| Baseline | 2.62 | Silly model: "tomorrow will be like today" |
| Real first model (LSTM) | 2.59| Slightly better than baseline |
| *Improved* model / variation of your choice | 2.52| Best overall, still shows signs of overfitting |

## Part 2: Sentiment analysis using LSTMs 

In Part 2 we will revisit the IMDB movie review classification task from an earlier assignment, this time using more sophisticated approaches and architectures.

Please refer to Chapter 11 of [our textbook](https://learning.oreilly.com/library/view/deep-learning-with/9781617296864) for background information on NLP and approaches for text representation in deep learning architectures.

The code (and much of the text) below is essentially from https://www.tensorflow.org/text/tutorials/text_classification_rnn

Useful sources and references for Part 2:

- https://colab.research.google.com/github/fchollet/deep-learning-with-python-notebooks/blob/master/chapter11_part01_introduction.ipynb
- https://colab.research.google.com/github/fchollet/deep-learning-with-python-notebooks/blob/master/chapter11_part02_sequence-models.ipynb

### Imports + auxiliary function
"""

import numpy as np

import tensorflow_datasets as tfds
import tensorflow as tf

tfds.disable_progress_bar()

"""Import `matplotlib` and create a helper function to plot graphs:"""

import matplotlib.pyplot as plt


def plot_graphs(history, metric):
  plt.plot(history.history[metric])
  plt.plot(history.history['val_'+metric], '')
  plt.xlabel("Epochs")
  plt.ylabel(metric)
  plt.legend([metric, 'val_'+metric])

"""### Setup input pipeline


The IMDB large movie review dataset is a *binary classification* dataset—all the reviews have either a *positive* or *negative* sentiment.

Download the dataset using [TFDS](https://www.tensorflow.org/datasets). See the [loading text tutorial](https://www.tensorflow.org/tutorials/load_data/text) for details on how to load this sort of data manually.

"""

dataset, info = tfds.load('imdb_reviews', with_info=True,
                          as_supervised=True)
train_dataset, test_dataset = dataset['train'], dataset['test']

train_dataset.element_spec

"""Initially this returns a dataset of (text, label pairs):"""

for example, label in train_dataset.take(1):
  print('text: ', example.numpy())
  print('label: ', label.numpy())

"""Next shuffle the data for training and create batches of these `(text, label)` pairs:"""

BUFFER_SIZE = 10000
BATCH_SIZE = 64

train_dataset = train_dataset.shuffle(BUFFER_SIZE).batch(BATCH_SIZE).prefetch(tf.data.AUTOTUNE)
test_dataset = test_dataset.batch(BATCH_SIZE).prefetch(tf.data.AUTOTUNE)

for example, label in train_dataset.take(1):
  print('texts: ', example.numpy()[:3])
  print()
  print('labels: ', label.numpy()[:3])

"""### Create the text encoder

The raw text loaded by `tfds` needs to be processed before it can be used in a model. The simplest way to process text for training is using the `TextVectorization` layer. This layer has many capabilities, but this tutorial sticks to the default behavior.

Create the layer, and pass the dataset's text to the layer's `.adapt` method:
"""

VOCAB_SIZE = 1000
encoder = tf.keras.layers.TextVectorization(
    max_tokens=VOCAB_SIZE)
encoder.adapt(train_dataset.map(lambda text, label: text))

"""The `.adapt` method sets the layer's vocabulary. Here are the first 20 tokens. After the padding and unknown tokens they're sorted by frequency: """

vocab = np.array(encoder.get_vocabulary())
vocab[:20]

"""Once the vocabulary is set, the layer can encode text into indices. The tensors of indices are 0-padded to the longest sequence in the batch (unless you set a fixed `output_sequence_length`):"""

encoded_example = encoder(example)[:3].numpy()
encoded_example

"""With the default settings, the process is not completely reversible. There are three main reasons for that:

1. The default value for `preprocessing.TextVectorization`'s `standardize` argument is `"lower_and_strip_punctuation"`.
2. The limited vocabulary size and lack of character-based fallback results in some unknown tokens.
"""

for n in range(3):
  print("Original: ", example[n].numpy())
  print("Round-trip: ", " ".join(vocab[encoded_example[n]]))
  print()

"""### Create the first model

Please refer to https://www.tensorflow.org/text/tutorials/text_classification_rnn for detailed explanation + diagram.
"""

model = tf.keras.Sequential([
    encoder,
    tf.keras.layers.Embedding(
        input_dim=len(encoder.get_vocabulary()),
        output_dim=64,
        # Use masking to handle the variable sequence lengths
        mask_zero=True),
    tf.keras.layers.Bidirectional(tf.keras.layers.LSTM(64)),
    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dense(1)
])

"""Please note that Keras sequential model is used here since all the layers in the model only have single input and produce single output. In case you want to use stateful RNN layer, you might want to build your model with Keras functional API or model subclassing so that you can retrieve and reuse the RNN layer states. Please check [Keras RNN guide](https://www.tensorflow.org/guide/keras/rnn#rnn_state_reuse) for more details.

The embedding layer [uses masking](https://www.tensorflow.org/guide/keras/masking_and_padding) to handle the varying sequence-lengths. All the layers after the `Embedding` support masking:
"""

print([layer.supports_masking for layer in model.layers])

"""To confirm that this works as expected, evaluate a sentence twice. First, alone so there's no padding to mask:"""

# predict on a sample text without padding.

sample_text = ('The movie was cool. The animation and the graphics '
               'were out of this world. I would recommend this movie.')
predictions = model.predict(np.array([sample_text]))
print(predictions[0])

"""Now, evaluate it again in a batch with a longer sentence. The result should be identical:"""

# predict on a sample text with padding

padding = "the " * 2000
predictions = model.predict(np.array([sample_text, padding]))
print(predictions[0])

"""Compile the Keras model to configure the training process:"""

model.compile(loss=tf.keras.losses.BinaryCrossentropy(from_logits=True),
              optimizer=tf.keras.optimizers.Adam(1e-4),
              metrics=['accuracy'])

"""### Train the model"""

history = model.fit(train_dataset, epochs=10,
                    validation_data=test_dataset,
                    validation_steps=30)

test_loss, test_acc = model.evaluate(test_dataset)

print('Test Loss:', test_loss)
print('Test Accuracy:', test_acc)

plt.figure(figsize=(16, 8))
plt.subplot(1, 2, 1)
plot_graphs(history, 'accuracy')
plt.ylim(None, 1)
plt.subplot(1, 2, 2)
plot_graphs(history, 'loss')
plt.ylim(0, None)

"""Run a prediction on a new sentence:

If the prediction is >= 0.0, it is positive else it is negative.
"""

sample_text = ('The movie was cool. The animation and the graphics '
               'were out of this world. I would recommend this movie.')
predictions = model.predict(np.array([sample_text]))

"""### Second model: stacking two LSTM layers

Please refer to https://www.tensorflow.org/text/tutorials/text_classification_rnn for additional explanation + diagram.

The interesting thing about using an `RNN` with `return_sequences=True` is that the output still has 3-axes, like the input, so it can be passed to another RNN layer, like this:
"""

model = tf.keras.Sequential([
    encoder,
    tf.keras.layers.Embedding(len(encoder.get_vocabulary()), 64, mask_zero=True),
    tf.keras.layers.Bidirectional(tf.keras.layers.LSTM(64,  return_sequences=True)),
    tf.keras.layers.Bidirectional(tf.keras.layers.LSTM(32)),
    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dropout(0.5),
    tf.keras.layers.Dense(1)
])

model.compile(loss=tf.keras.losses.BinaryCrossentropy(from_logits=True),
              optimizer=tf.keras.optimizers.Adam(1e-4),
              metrics=['accuracy'])

history = model.fit(train_dataset, epochs=10,
                    validation_data=test_dataset,
                    validation_steps=30)

test_loss, test_acc = model.evaluate(test_dataset)

print('Test Loss:', test_loss)
print('Test Accuracy:', test_acc)

# predict on a sample text without padding.

sample_text = ('The movie was not good. The animation and the graphics '
               'were terrible. I would not recommend this movie.')
predictions = model.predict(np.array([sample_text]))
print(predictions)

plt.figure(figsize=(16, 6))
plt.subplot(1, 2, 1)
plot_graphs(history, 'accuracy')
plt.subplot(1, 2, 2)
plot_graphs(history, 'loss')

"""

### TODO 2: Improve the solution for IMDB sentiment analysis
Write code to produce another solution to the movie review problem that outperforms the two solutions provided above, i.e, has a higher test accuracy.

You can use a (combination of) different architecture, dropout and/or other regularization strategies, hyperparameter optimizations, masking, pretrained embeddings, or any other acceptable "trick" in the deep learning world."""

model = tf.keras.Sequential([
    encoder,
    tf.keras.layers.Embedding(
        input_dim=len(encoder.get_vocabulary()),
        output_dim=64,
        # Use masking to handle the variable sequence lengths
        mask_zero=True),
    tf.keras.layers.Bidirectional(tf.keras.layers.LSTM(64)),
    tf.keras.layers.Dropout(0.5),
    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dropout(0.5),
    tf.keras.layers.Dense(1)
])

model.compile(loss=tf.keras.losses.BinaryCrossentropy(from_logits=True),
              optimizer=tf.keras.optimizers.Adam(1e-4),
              metrics=['accuracy'])

history = model.fit(train_dataset, epochs=10,
                    validation_data=test_dataset,
                    validation_steps=30)

test_loss, test_acc = model.evaluate(test_dataset)

print('Test Loss:', test_loss)
print('Test Accuracy:', test_acc)

# predict on a sample text without padding.

sample_text = ('The movie was not good. The animation and the graphics '
               'were terrible. I would not recommend this movie.')
predictions = model.predict(np.array([sample_text]))
print(predictions)

plt.figure(figsize=(16, 6))
plt.subplot(1, 2, 1)
plot_graphs(history, 'accuracy')
plt.subplot(1, 2, 2)
plot_graphs(history, 'loss')

model2 = tf.keras.Sequential([
    encoder,
    tf.keras.layers.Embedding(
        input_dim=len(encoder.get_vocabulary()),
        output_dim=64,
        # Use masking to handle the variable sequence lengths
        mask_zero=True),
    tf.keras.layers.Bidirectional(tf.keras.layers.LSTM(64)),
    tf.keras.layers.Dropout(0.5),
    tf.keras.layers.Dense(24, activation='relu'),
    tf.keras.layers.Dropout(0.5),
    tf.keras.layers.Dense(1)
])

model2.compile(loss=tf.keras.losses.BinaryCrossentropy(from_logits=True),
              optimizer=tf.keras.optimizers.Adam(1e-4),
              metrics=['accuracy'])

history = model2.fit(train_dataset, epochs=15,
                    validation_data=test_dataset,
                    validation_steps=30)

test_loss, test_acc = model2.evaluate(test_dataset)

print('Test Loss:', test_loss)
print('Test Accuracy:', test_acc)

# predict on a sample text without padding.

sample_text = ('The movie was not good. The animation and the graphics '
               'were terrible. I would not recommend this movie.')
predictions = model2.predict(np.array([sample_text]))
print(predictions)

plt.figure(figsize=(16, 6))
plt.subplot(1, 2, 1)
plot_graphs(history, 'accuracy')
plt.subplot(1, 2, 2)
plot_graphs(history, 'loss')

"""### Summary table
(Example, manually generated)

You can use the table below to show a summary of the experimental results. **Replace the Test Accuracy values and other contents with your own!**

| Method | Test Accuracy | Remarks |
| --- | --- | --- |
| First model | 0.86 | Baseline |
| Second model (LSTM) | 0.82 | Worse than baseline |
| *Improved* model / variation of your choice | 0.87 | Best overall |

## Part 3: NLP using Transformers 

In Part 3 we will look at the Transformer architecture and how it can be used in a specific NLP task, machine translation (from English to Spanish).

Please refer to Chapter 11 of [our textbook](https://learning.oreilly.com/library/view/deep-learning-with/9781617296864) for additional information.

Useful sources and references for Part 3:

- https://colab.research.google.com/github/fchollet/deep-learning-with-python-notebooks/blob/master/chapter11_part03_transformer.ipynb
- https://colab.research.google.com/github/fchollet/deep-learning-with-python-notebooks/blob/master/chapter11_part04_sequence-to-sequence-learning.ipynb

### Setup
"""

!wget http://storage.googleapis.com/download.tensorflow.org/data/spa-eng.zip
!unzip -q spa-eng.zip

text_file = "spa-eng/spa.txt"
with open(text_file) as f:
    lines = f.read().split("\n")[:-1]
text_pairs = []
for line in lines:
    english, spanish = line.split("\t")
    spanish = "[start] " + spanish + " [end]"
    text_pairs.append((english, spanish))

import random
print(random.choice(text_pairs))

import random
random.shuffle(text_pairs)
num_val_samples = int(0.15 * len(text_pairs))
num_train_samples = len(text_pairs) - 2 * num_val_samples
train_pairs = text_pairs[:num_train_samples]
val_pairs = text_pairs[num_train_samples:num_train_samples + num_val_samples]
test_pairs = text_pairs[num_train_samples + num_val_samples:]

"""**Vectorizing the English and Spanish text pairs**"""

import tensorflow as tf
import string
import re

from tensorflow import keras
from tensorflow.keras import layers

strip_chars = string.punctuation + "¿"
strip_chars = strip_chars.replace("[", "")
strip_chars = strip_chars.replace("]", "")

def custom_standardization(input_string):
    lowercase = tf.strings.lower(input_string)
    return tf.strings.regex_replace(
        lowercase, f"[{re.escape(strip_chars)}]", "")

vocab_size = 15000
sequence_length = 20

source_vectorization = layers.TextVectorization(
    max_tokens=vocab_size,
    output_mode="int",
    output_sequence_length=sequence_length,
)
target_vectorization = layers.TextVectorization(
    max_tokens=vocab_size,
    output_mode="int",
    output_sequence_length=sequence_length + 1,
    standardize=custom_standardization,
)
train_english_texts = [pair[0] for pair in train_pairs]
train_spanish_texts = [pair[1] for pair in train_pairs]
source_vectorization.adapt(train_english_texts)
target_vectorization.adapt(train_spanish_texts)

"""**Preparing datasets for the translation task**"""

batch_size = 64

def format_dataset(eng, spa):
    eng = source_vectorization(eng)
    spa = target_vectorization(spa)
    return ({
        "english": eng,
        "spanish": spa[:, :-1],
    }, spa[:, 1:])

def make_dataset(pairs):
    eng_texts, spa_texts = zip(*pairs)
    eng_texts = list(eng_texts)
    spa_texts = list(spa_texts)
    dataset = tf.data.Dataset.from_tensor_slices((eng_texts, spa_texts))
    dataset = dataset.batch(batch_size)
    dataset = dataset.map(format_dataset, num_parallel_calls=4)
    return dataset.shuffle(2048).prefetch(16).cache()

train_ds = make_dataset(train_pairs)
val_ds = make_dataset(val_pairs)

for inputs, targets in train_ds.take(1):
    print(f"inputs['english'].shape: {inputs['english'].shape}")
    print(f"inputs['spanish'].shape: {inputs['spanish'].shape}")
    print(f"targets.shape: {targets.shape}")

"""### The Transformer encoder"""

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers

class TransformerEncoder(layers.Layer):
    def __init__(self, embed_dim, dense_dim, num_heads, **kwargs):
        super().__init__(**kwargs)
        self.embed_dim = embed_dim
        self.dense_dim = dense_dim
        self.num_heads = num_heads
        self.attention = layers.MultiHeadAttention(
            num_heads=num_heads, key_dim=embed_dim)
        self.dense_proj = keras.Sequential(
            [layers.Dense(dense_dim, activation="relu"),
             layers.Dense(embed_dim),]
        )
        self.layernorm_1 = layers.LayerNormalization()
        self.layernorm_2 = layers.LayerNormalization()

    def call(self, inputs, mask=None):
        if mask is not None:
            mask = mask[:, tf.newaxis, :]
        attention_output = self.attention(
            inputs, inputs, attention_mask=mask)
        proj_input = self.layernorm_1(inputs + attention_output)
        proj_output = self.dense_proj(proj_input)
        return self.layernorm_2(proj_input + proj_output)

    def get_config(self):
        config = super().get_config()
        config.update({
            "embed_dim": self.embed_dim,
            "num_heads": self.num_heads,
            "dense_dim": self.dense_dim,
        })
        return config

"""### The Transformer decoder"""

class TransformerDecoder(layers.Layer):
    def __init__(self, embed_dim, dense_dim, num_heads, **kwargs):
        super().__init__(**kwargs)
        self.embed_dim = embed_dim
        self.dense_dim = dense_dim
        self.num_heads = num_heads
        self.attention_1 = layers.MultiHeadAttention(
            num_heads=num_heads, key_dim=embed_dim)
        self.attention_2 = layers.MultiHeadAttention(
            num_heads=num_heads, key_dim=embed_dim)
        self.dense_proj = keras.Sequential(
            [layers.Dense(dense_dim, activation="relu"),
             layers.Dense(embed_dim),]
        )
        self.layernorm_1 = layers.LayerNormalization()
        self.layernorm_2 = layers.LayerNormalization()
        self.layernorm_3 = layers.LayerNormalization()
        self.supports_masking = True

    def get_config(self):
        config = super().get_config()
        config.update({
            "embed_dim": self.embed_dim,
            "num_heads": self.num_heads,
            "dense_dim": self.dense_dim,
        })
        return config

    def get_causal_attention_mask(self, inputs):
        input_shape = tf.shape(inputs)
        batch_size, sequence_length = input_shape[0], input_shape[1]
        i = tf.range(sequence_length)[:, tf.newaxis]
        j = tf.range(sequence_length)
        mask = tf.cast(i >= j, dtype="int32")
        mask = tf.reshape(mask, (1, input_shape[1], input_shape[1]))
        mult = tf.concat(
            [tf.expand_dims(batch_size, -1),
             tf.constant([1, 1], dtype=tf.int32)], axis=0)
        return tf.tile(mask, mult)

    def call(self, inputs, encoder_outputs, mask=None):
        causal_mask = self.get_causal_attention_mask(inputs)
        if mask is not None:
            padding_mask = tf.cast(
                mask[:, tf.newaxis, :], dtype="int32")
            padding_mask = tf.minimum(padding_mask, causal_mask)
        attention_output_1 = self.attention_1(
            query=inputs,
            value=inputs,
            key=inputs,
            attention_mask=causal_mask)
        attention_output_1 = self.layernorm_1(inputs + attention_output_1)
        attention_output_2 = self.attention_2(
            query=attention_output_1,
            value=encoder_outputs,
            key=encoder_outputs,
            attention_mask=padding_mask,
        )
        attention_output_2 = self.layernorm_2(
            attention_output_1 + attention_output_2)
        proj_output = self.dense_proj(attention_output_2)
        return self.layernorm_3(attention_output_2 + proj_output)

"""### Putting it all together: A Transformer for machine translation

**PositionalEmbedding layer**
"""

class PositionalEmbedding(layers.Layer):
    def __init__(self, sequence_length, input_dim, output_dim, **kwargs):
        super().__init__(**kwargs)
        self.token_embeddings = layers.Embedding(
            input_dim=input_dim, output_dim=output_dim)
        self.position_embeddings = layers.Embedding(
            input_dim=sequence_length, output_dim=output_dim)
        self.sequence_length = sequence_length
        self.input_dim = input_dim
        self.output_dim = output_dim

    def call(self, inputs):
        length = tf.shape(inputs)[-1]
        positions = tf.range(start=0, limit=length, delta=1)
        embedded_tokens = self.token_embeddings(inputs)
        embedded_positions = self.position_embeddings(positions)
        return embedded_tokens + embedded_positions

    def compute_mask(self, inputs, mask=None):
        return tf.math.not_equal(inputs, 0)

    def get_config(self):
        config = super(PositionalEmbedding, self).get_config()
        config.update({
            "output_dim": self.output_dim,
            "sequence_length": self.sequence_length,
            "input_dim": self.input_dim,
        })
        return config

"""**End-to-end Transformer**"""

embed_dim = 256
dense_dim = 2048
num_heads = 8

encoder_inputs = keras.Input(shape=(None,), dtype="int64", name="english")
x = PositionalEmbedding(sequence_length, vocab_size, embed_dim)(encoder_inputs)
encoder_outputs = TransformerEncoder(embed_dim, dense_dim, num_heads)(x)

decoder_inputs = keras.Input(shape=(None,), dtype="int64", name="spanish")
x = PositionalEmbedding(sequence_length, vocab_size, embed_dim)(decoder_inputs)
x = TransformerDecoder(embed_dim, dense_dim, num_heads)(x, encoder_outputs)
x = layers.Dropout(0.5)(x)
decoder_outputs = layers.Dense(vocab_size, activation="softmax")(x)
transformer = keras.Model([encoder_inputs, decoder_inputs], decoder_outputs)

"""**Training the sequence-to-sequence Transformer**"""

transformer.compile(
    optimizer="rmsprop",
    loss="sparse_categorical_crossentropy",
    metrics=["accuracy"])
transformer.fit(train_ds, epochs=10, validation_data=val_ds)

"""**Translating new sentences with our Transformer model**"""

import numpy as np
spa_vocab = target_vectorization.get_vocabulary()
spa_index_lookup = dict(zip(range(len(spa_vocab)), spa_vocab))
max_decoded_sentence_length = 20

def decode_sequence(input_sentence):
    tokenized_input_sentence = source_vectorization([input_sentence])
    decoded_sentence = "[start]"
    for i in range(max_decoded_sentence_length):
        tokenized_target_sentence = target_vectorization(
            [decoded_sentence])[:, :-1]
        predictions = transformer(
            [tokenized_input_sentence, tokenized_target_sentence])
        sampled_token_index = np.argmax(predictions[0, i, :])
        sampled_token = spa_index_lookup[sampled_token_index]
        decoded_sentence += " " + sampled_token
        if sampled_token == "[end]":
            break
    return decoded_sentence

test_eng_texts = [pair[0] for pair in test_pairs]
for _ in range(20):
    input_sentence = random.choice(test_eng_texts)
    print("-")
    print(input_sentence)
    print(decode_sequence(input_sentence))

"""# Conclusions
### Part 1
 At the beginning of this journal we were tasked with testing a simple solution, a model, which could accurately predict temperature after training on data from a well-known data set-given to us by the weather station at the Max Planck Institute for Biogeochemistry in Jena, Germany. The statistic of importance was the MAE score. After testing and getting an MAE of 2.62 on a simple, non-machine learning solution for the temperature problem we then were tasked with running a machine learning based solution and comparing those results with the previous non-machine learning results. The data was parsed, normalized and transformed into a suitable form for use within an LSTM and GRU model. Finally, we crafted our own machine learning solutions, however complex and clever we desired to be until the soltuions showed sufficiently better MAE scores than the two prior implementations.  

 | Method | Test MAE | Remarks |
| --- | --- | --- |
| Baseline | 2.62 | Temperature is assumed to be like the day proceeding |
| Real first model (LSTM) | 2.59| Overly complex to a fault |
| *Improved* model / variation of your choice | 2.52| Best overall, still shows signs of overfitting |

The results for the three tests are captured in the table. Within the journal you can also find the graphs which relay the improvements made with each succesive change in the model. 
The slow or marginal improvements despite wholistic changes to the models could be attributed to the fact that the problem's ideal solution lies in a simpler solution space than our more complex machine learning created hypothesis spaces. There also exists innumerable changes that can be made to a machine learning model. In my final iteration for the temperature problem I added drop out layers and changed the layer types but there exists many more additional changes that could potentially have led to greater decreases in the MAE score.
Some key differences in the model is the rate at which overfitting began to appear and the best MAE scores overall. The best MAE scores overall are shown quickly by the third model but it also demonstrated a tendency to overfit quickly. Perhaps stopping the modela t 4 epochs or continued for the greater number of epochs might change that. The second model takes longer to overfit but never quitie gets to some of the MAE scores that the third model manages.  

### Part 2
This section of the journal deals with the implementation of multiple LSTM models. The first has an architecture captured by the following image:

![image.png](data:image/png;base64,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)

The bidirectional LSTM produces an accuracy that is hard to exceed. After implementing a single bidirectional LSTM we train a stacked version of the LSTM model for sentiment classification. The next implemenetation looks like the following image:

![image.png](data:image/png;base64,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)

The stacked LSTM produces worse results. This could be because the complexity or the length of the text we are given may lend to more simple architectures or solution spaces. In order to test this hypothesis I tested the first architecture a few more times with different hyperparameters to see if I would consistently increase the accuracy of the model or produce accuracies greater than the stacked LSTM model. To my surprise the single bidrectional model consistently produced greater accuracy scores but the improvements made by changing the hyperparameters were miniscule in my tests. The results are captured below. 


| Method | Test Accuracy | Remarks |
| --- | --- | --- |
| First model | 0.86 | Baseline |
| Second model (LSTM) | 0.82 | Worse than baseline |
| *Improved* model / variation of your choice | 0.87 | Best overall |


In the case of part two additional experiments could include hyperparameter fine-tuning of the stacked LSTM, testing of a GRU model on the sentiment data, machine learning  on the sentiment data as well as a pre-trained model. My hypothesis is that a pretrained model with pre trained weights would do well.
"""